---
title: "SWPanalyzer"
output:
  pdf_document: default
  html_document: default
date: "2024.11.27"
editor_options: "Code developed by Juan Camilo Barbosa-Caro. Team signaling @ Frommer
  Lab. Düsseldorf-Germany."
chunk_output_type: console
---

#//////////////////////////////// READ THIS //////////////////////////////////////

                                    DESCRIPTION 
        
This script transforms and analyzes raw data from electrophysiological recordings of wounded Arabidopsis leafs, 
which generates signals known as Slow Wave Potential (SWP) (https://www.nature.com/articles/nature12478).
It is designed to manage SWPs recorded with the software LabScribe. 
The ending of the wounding event has to be marked by a F1 keypress.


Different SWP parameters are quantified at the wounded and receiving leaf by a custom-made algorithm.
Initially, the recorded voltage vector, at 1 Hz sample rate, is smoothed with a Savitzky-Golay filter, 
with a moving window of 3 points and a fitting polynomial of order 1. 
From that filtered signal the parameters are automatically calculated as follows:

Reference parameters
  - First baseline – average voltage from the beginning of the trace to the stimulus mark
  (marked by pressing F1 key during recording).
  -	depol.peak – minimum voltage of the complete trace.
  -	first.hyperpol.peak – maximum voltage between stimulus mark and depol.peak
  -	second.hyperpol.peak – maximum voltage between depol.peak and the recording end.

Hyperpolarization phase
  -	hyperpol.amplitude – the voltage difference between the first baseline and the first.hyperpol.peak.
  -	hyperpol.slope – the maximum point of the first derivative of the trace between the stimulus mark and the first.hyperpol.peak.
  -	hyperpol.duration – Time difference between hyperpol.slope and depol.slope (see below).

Depolarization phase
  -	depol.slope – minimum point of the first derivative of the trace between first.hyperpol.peak and depol.peak.
  -	depol.amplitude – Voltage difference between first.hyperpol.peak and depol.peak.
  -	depol.duration – time difference between the points where voltage equals (first.hyperpol.peak - depol.peak)/2 and (second.hyperpol.peak - depol.peak)/2.

Repolarization phase
  -	bl.2nd (second baseline) – average voltage in the final 60 s of the recording.
  -	hyperpol.amplitude.2nd – voltage difference between second.hyperpol.peak and bl.2nd.

  
  
    
    INPUT:
Data for one or multiple experiments regardless of the amount of genotypes screened.
With this labScribe software and hardware up to 4 electrodes can be used simultaneously. Hence, 2 plants per file. 
Either 1 or 2 plants can be analyzed, make sure to follow this labeling rules.
    
    
One or multiple folders with .txt files having the following structure:
 - Folder named: "YYMMDD". Note: You can simultaneously analyze as many folders as needed
 - Raw data inside that folder should be in .txt files, as exported from LabScribe

In LabScribe name the electrodes (= column name in the .txt file) used in the recording with the following structure.
All the information about the experiment are in the leaf 8 label. 

        Leaf 8 --         "Ez_Lyy.xPG_w" 
        Leaf 13--         "Ez_Lyy.x"
        Empty Electrode-- "Ez_Leer"
where:
                 z is the electrode number (1 to 4)
                 y is the leaf on which that electrode is (08 or 13)
                 x is the plant (1 or 2)
                 PG stands for Plyer and Gears as the stimulation device.
                 w is the GENOTYPE (text of any length, just avoid "_") it has to be consistent for the system to compile them all together.

Example for 2 plant recording "E1_L08.1PG_Col0" , "E2_L13.1", "E3_L13.2" , "E4_L08.2PG_mutant"

- Col-0 with electrodes 1 on leaf 8 and 2 on leaf 13
- mutant with electrodes 3 on leaf 13 and 2 on leaf 08

    OUTPUT:   
1. A folder with a name of choice inputed in step 2.1
In this folder: 
2.  a >genotype<->date< folder with all the traces corresponding to that combination. Each image is saved as the plant#.L##
3.  >genotype<.csv file with the raw data organized as a data frame to use with R or any other coding language.
4.  >genotype<Summary.csv file summarizing for every leaf of every plant all the parameters calculated. Each parameter is a column.
5.  >date<-basicStats.csv file with the Shapiro-Wilk normality test, the Mann-Whitney U test and the Kruskal-Wallis test for 
each parameter of each leaf of each genotype. Both non-parametric tests are compared to Col0 or any other group stated in step 2.1. 
This is only a guide. ABSOLUTELY re-run these tests or use other more suited to your data manually with the data provided in point 4.
6.  >date-parameter<.pdf files. Violin plot with all the point separated by genotype and leaf. One for each parameter.
7.  Mean->genotype-L##<.pdf files. The graphical mean of all traces ± SEM. One for each leaf of each genotype. 


                                   DISCLAIMER OF SCRIPT BIASES 
Traces are filtered with a Savitzky-Golay method which reduces the amplitude (by around 5 mV) of traces 
with a very sharp spike in the peak depolarization. 
If a mutant has a phenotype within 5 mV range in the peak amplitude, it will be likely undermined by this quantification method.




#////////////////////////////// START HERE //////////////////////////////////////
If you struggle understanding these instructions, you might have a knowledge gap.
Fill you knowledge gaps about R here:
https://rmarkdown.rstudio.com/authoring_quick_tour.html

                                  INSTRUCTIONS

Follow these steps to use this script:

  1. Carefully label and export your data from LabScribe. Double check that the name of the electrodes is in the required format (see INPUT section above)
  IMPORTANT: when exporting include the "TimeOfDay" by ticking the box when the software asks. 
  
  2. Download and open this "SWPanalyzer.Rmd" file in Rstudio.
  
  3. Click on create a project on the top left of this window to create a new project. Select the the option "Create new Directory".
  This will create a folder with a ".Rproj" file inside, both with the same name. In that folder all the input and output will be located.
  
  This window will probably close and a new space will be created. Open this code again in that space.

  4. In the "gear" configurations button, at the top of the window where you are reading this instructions, select "Chunk output in console" instead of "Chunk output inline". 
  This will show all the steps of the process properly in the console.
  
  5. Paste a copy of the exported "yymmdd" folders with the ".txt" data from one batch of experiments into the home folder you just created (use format described above in the INPUT section). 
  
  6. Run the chunks (click on the green arrow on the right) one by one and in order. 
    If ran successfully, each chunk will indicate you to go to the next.
  
  
  Note: The analysis is divided in 4 sections, each with multiple chunks. Run them in order and one by one. 
        There is a checkpoint between sections; this means that if necessary to close the program and continue later, do it after finishing one full section.  
        REMEMBER! run section 1 every time you open the program, even if you are not starting from scratch.

         Analysis sections:
      1. Function and library loading (Run every time you start the program)
      2. Load and convert the data
      3. Pick, trim and analyze summaryzed traces
      4. Plot and check for normality of calculated parameters. Also plot a mean ±SEM trace for a genotype or group of traces.
      5. Plot a mean ±SEM trace for a genotype or group of traces picked manually of the pool previously generated.



///////////////////////////////////////// RUN HERE //////////////////////////////////////
   
   
   
                    
# SECTION 1. Function and library loading >RUN EVERY TIME YOU OPEN RSTUDIO<

- Run this chunk once every time you start the program.
You will get an ERROR if you don't have the packages installed in your computer does it by typing in the console:
install.packages("name of package") 
example: install.packages("ggplot2")
```{r}
# load packages
library(ggplot2)
library(tidyr)
library(pracma)
library(signal)
library(dplyr)
library(plotrix)
Parameters = c("hyperpol.slope",
               "hyperpol.amplitude",
               "hyperpol.duration",
               
               "depol.slope",
               "depol.amplitude",
               "depol.duration",
               
               "hyperpol.amplitude.2nd", 
               "bl.2nd" )
# Function for parameter finding
DataExtraction <- function(data, date){ 
  output <- list()
  time1 = data$Time
  ToD = data$TimeOfDay
  #determine which channels have info

  # is there a leaf 08?
  L08.exist = length( grep("L08",names(data)) ) >= 1 
  # is there a leaf 13?
  L13.exist = length( grep("L13",names(data)) ) >= 1 
  if( L08.exist == TRUE ) {
    PlantNumber = names(data)[grep("L08",names(data)) ] %>% substr(8,8) %>% as.numeric()
  } else if( L13.exist == TRUE ){
    PlantNumber = names(data)[grep("L13",names(data)) ] %>% substr(8,8) %>% as.numeric()
  }
  
  index = 1
  # Extract info one plant at a time.
  for( n in PlantNumber){
  # determine the leaf 1 or 2 identity (8, 13)
    if( L08.exist == TRUE && L13.exist == FALSE ) {
        leaf1 = paste("L08.", n, sep = "")
        plant1 = data_frame("L08" = data[, grep(leaf1, names(data)) ])  # pick the columns w/ the data
        info1 = names(data)[  grep(leaf1 , names(data))  ]
    } else if( L08.exist == FALSE && L13.exist == TRUE ){ 
        leaf1 = paste("L13.", n, sep = "")
        plant1 = data_frame("L13" = data[, grep(leaf1, names(data)) ])  # pick the columns w/ the data
        info1 = names(data)[  grep(leaf1 , names(data))  ]
    } else if ( L08.exist == TRUE && L13.exist == TRUE ) {# if 
        leaf1 = paste("L08.", n, sep = "")
        leaf2 = paste("L13.", n, sep = "")
        plant1 = data[, grep(leaf1, names(data)): grep(leaf2, names(data))] # pick the columns w/ the data
        # extract info from L08 col (Stim,genotype)
        # from cols 2,3 which have 08
        info1 = names(data)[  grep( paste("L08.", n, sep = ""), names(data) )  ]
    }

    
    # extract from that all necessary info
    stim1 = strsplit(info1,"_")[[1]][2] # separate by "_". save part with the stim. e.g. "L08.1CG"
    stim1 <- substr(stim1,6,nchar(stim1))
    genotype1 = strsplit(info1,"_")[[1]][3] # separate by "_". save part with the stim. e.g. "L08.1CG"
    # rename (Time, L08(V), L13)(V)) and tidy, and convert to numeric corresponding cols.
    plant1 <-  cbind( ToD, time1, plant1 )
    names(plant1)[which(names(plant1)=="time1")] <- "Seconds"
    names(plant1)[which(names(plant1)=="ToD")] <- "DayTime"
    if(L08.exist == TRUE ){
      names(plant1)[   grep("08", names(plant1))   ] <- "L08"
    } 
    if(L13.exist == TRUE){
      names(plant1)[   grep("13", names(plant1))   ] <- "L13"
    }
    # remove initial part if there are to beginnings of the recording.
    if( length(which(plant1$Seconds==0))>1 ){
      print("t=0 identified twice in the recording. Took the second as start")
      plant1 = plant1[max(which(plant1$Seconds==0)):nrow(plant1),]
    }
      
      
    if( ncol(plant1)>3 ){
      plant1 = gather(plant1, "Leaf", "V", 3:4)
    } else if( ncol(plant1)==3 ){
      plant1 = gather(plant1, "Leaf", "V", 3)
    }
    
    plant1$plant = n
    plant1$Seconds = as.numeric(plant1$Seconds)
    plant1$`V` = as.numeric(plant1$`V`)*100
    plant1$Genotype = genotype1
    plant1$Stim = stim1
    plant1$Date = date
    plant1$Plot = "No"
    # get in F1 for the stimulation moment in case there are none
    if( length(which(plant1$DayTime == "F1"))==0 ){
      plant1$DayTime[which(plant1$Seconds==90)] = "F1"
      plant1$V[which(plant1$Seconds==90)] = NaN
    }
    
    plant1 = list(plant1)
    output <- append(output,plant1) 
    names(output[index]) <-  paste("plant",n,sep = "")
    index = index+1

  }
  return(output)
}###  LabScribe into data frame. PlantNumber= 1 or 2 per trace (Should make it 4, for each electrode)
AmIDone <- function(file){
  CheckTraces = read.csv(file) 
  pendingList = c()
  if( nrow(  dplyr::filter(CheckTraces, Plot=="No" ))>0  ){
    print( paste("You still need to analyse these plants for ",
                 file, ":", sep = "") )
    pendingTraces = dplyr::filter(CheckTraces, Plot=="No" )
    for(i in unique(pendingTraces$Date) ){
      missingDates = i
      ids = unique( pendingTraces$id[which(pendingTraces$Date==i)] )
      print( paste(i,ids,sep = "-")  )
      pendingList = append(pendingList,paste(i,ids,sep = "-") )
    }
  } else { 
    print( paste("You're done with", file, "!!!") ) 
    }
  return(c(pendingList))
  
}
calculateslope <- function(vector) {
  slopetrace = NULL
  for( i in 2:length(vector)){
    slopei = vector[i]-vector[i-1]
    slopetrace = append(slopetrace, slopei)  
  }
  slopetrace = append(slopetrace, slopetrace[length(slopetrace)])
  return(slopetrace)
}
findSWPvalues <- function(trace, stimulus.time, sample.rate = 1){
  ### Set reference time 0 when stimulus is applied: either at the first F1 value or or at the first maximum value. Determined as input of the function
  stimFrame = stimulus.time*sample.rate 
  
  ### Filter signal
  trace[which(trace < -150)] = trace[1] # Make extreme values equal baseline. It's when the electrode looses contact.
  # smooth with Savitzky-Golay filter. 
  # n is the amount of point befor/after the nth point to be averaged
  # p is the filter order. Dont know what that is.
   trace = sgolayfilt(na.omit(trace) , p = 1, n = 3)
  # trace = na.omit(trace) ## if not filtering, just omit NaNs
  # Check trace (for debugging)
  plot(trace, type = "l")+
    abline(v=stimFrame) 
  


                        ### Initial baseline
  bl.1st = mean(trace[ 1:(stimFrame-2)]) # average from 0 to before stimFrame
  
  
  
  ### Find peak depolarization
  maxDepol = min(   na.omit( trace[ stimFrame:length(trace) ] )   ) # find peak depol. It's extracellular recording, so depol goes to negative (this information os not needed I guess)
  
  depolFrame = min(which(trace == maxDepol)) # Find frame at maximum depol 
  
   
                        ### hyperpol.amplitude
  ### Find peak of first hyperpolarization between stimulus and depol peak
  maxHyperpol = max(  na.omit(trace[ (stimFrame) : depolFrame ])   )
  hyperpolFrame =  min(which(trace == maxHyperpol)) # Find frame at maximum hyperpol
  hyperpol.amplitude = maxHyperpol-bl.1st

                        ### depol.amplitude
  depol.amplitude = maxDepol - abs(maxHyperpol) # Calculate max depol from the peak of hyperpol rather than from the initial baseline

  
  
                        ### minDepolrate frame

  # find the peak slope at depol part of the trace
  # focus on the chunk between max hyperpol and max depol
  depolTrace = trace[hyperpolFrame:depolFrame] #trace[ (stimFrame+10) : depolFrame  ]  
  depoltrace.firstderivative = calculateslope(depolTrace)
  depol.slope =  min(depoltrace.firstderivative)
  depol.slope.frame = min( which(depoltrace.firstderivative == depol.slope) )+hyperpolFrame
  

  
# to find half max frame, substract the halfMax V from the trace and pick the closest to 0.
  halfmax.depol = round( maxHyperpol - (( abs(maxDepol)+abs(maxHyperpol) )/2), 2 )
  halfmax.depol.frame = max( which( abs(depolTrace-halfmax.depol) <=
                                      min(abs(depolTrace-halfmax.depol))+1 ) )   + 
                        hyperpolFrame
  
   
                      ### max hyperpol rate
  # focus on the chunk between max hyperpol and max depol
  check.behind = 20
  hyperpolTrace = trace[ (hyperpolFrame-check.behind) : (hyperpolFrame+2)] # checks the trace 20s before the peak hyperpol.
  hyperpoltrace.firstderivative = calculateslope(hyperpolTrace)
  hyperpol.slope = max(hyperpoltrace.firstderivative)
  ### Save time of max slope
  hyperpol.slope.frame = min( which(hyperpoltrace.firstderivative == hyperpol.slope) ) +
                          hyperpolFrame-check.behind 

  
                      ### hyperpol.duration from max hyperpol slope to min depol slope
  
  hyperpol.duration = depol.slope.frame - hyperpol.slope.frame
  
                          ### second baseline
  ### Find second baseline i.e. after repolarization
  bl.2nd = mean(trace[   (length(trace)-60): length(trace)   ])
  
  
  
  
                        ###hyperpol.amplitude.2nd
    # focus on repolarization part of the trace
  repolTrace = trace[(depolFrame+1):length(trace)]
  maxRepol = max(repolTrace) # maximum repolarization
  maxRepolframe = which(repolTrace == maxRepol)+depolFrame
  hyperpol.amplitude.2nd = maxRepol-bl.2nd # Find hyperpolarization amplitude in the recovery phase

                        ### maxRepol/2 frame
  halfRepol = maxRepol + ((maxDepol-maxRepol)/2) # bl.2nd + (maxDepol - bl.2nd)/2 # 
  halfmax.repol.frame =  max( which( abs(repolTrace-halfRepol) <= min(abs(repolTrace-halfRepol))+1 ) )   + depolFrame

                            ### Depolarization duration
  #Time from halfmax raise and decay        
  depol.duration = halfmax.repol.frame - halfmax.depol.frame

  
  
                            ### Change reference frame with the stimulus frame = 0
  hyperpol.slope.frame = hyperpol.slope.frame - stimFrame
  hyperpolFrame = hyperpolFrame  - stimFrame
  depol.slope.frame = depol.slope.frame - stimFrame
  halfmax.depol.frame = halfmax.depol.frame - stimFrame
  depolFrame = depolFrame - stimFrame
  halfmax.repol.frame = halfmax.repol.frame - stimFrame
  
  
  #return all these
  SWPvalues = data.frame(
  bl.1st,
  maxDepol,
  hyperpol.amplitude,
  hyperpolFrame,
  hyperpol.slope,
  hyperpol.slope.frame,
  depol.slope.frame,
  maxHyperpol,
  halfmax.depol.frame,
  depol.slope,
  depol.amplitude,
  depolFrame,
  halfmax.repol.frame,
  maxRepol, 
  hyperpol.amplitude.2nd,
  bl.2nd,
  depol.duration,
  hyperpol.duration,
  stimFrame
  )
  return( list(trace, SWPvalues))
  
}
trimTrace <-function(trace, second){
  trimFrame = which(trace$Seconds == second)
  trace = trace[1:trimFrame,]
  plot(trace$V, type="l")
  return(trace)
}
plotAndAnalyze <- function(genotypeFile){
  # Load file newly
  ALLtraces = read.csv( genotypeFile )
  # Load summary file if exists
  if( file.exists( paste(savename,"Summary.csv",sep = "")) )  {
    fTraceSummary = read.csv( paste(savename,"Summary.csv",sep = "") )
  } else {
    fTraceSummary = NULL
  }
  # start w/ emptying variables
  Date = c()
  Stim = c()
  id = c()
  Leaf = c()
#### filter to get to one single trace
  subSet0 = dplyr::filter(ALLtraces,Plot == "No") 
  for (datei in unique(subSet0$Date) ){ # pick one date
    subSet1 = dplyr::filter(subSet0, Date == datei)
    # create folder if it doesn't exist
    if( dir.exists(paste( savename,"-",datei,sep = ""))==FALSE ){
      dir.create(paste( savename,"-",datei,sep = ""))
    }
     for( stimi in unique(subSet1$Stim) ) { # pick one stimulus form
      subSet2 = dplyr::filter(subSet1, Stim == stimi) 
      for( IDi in unique(subSet2$id) ) { # pick one id
        subSet3 = dplyr::filter(subSet2, id == IDi) 
        for ( leafi in unique(subSet3$Leaf) ){ # pick a leaf
          # single trace to be analyzed
          trace = dplyr::filter(subSet3, Leaf == leafi)
          
          ### Check trace to decide if needs trimming of final part
          
          
          plot(trace$V, type="l")
          
          
          # Trim or not (I think it needs more explanation why we should trim traces)
          answer <- readline (prompt="Trim trace? Second+ENTER, just ENTER to skip trimming, or >n< for skipping & erasing trace  ")
          if(nchar(answer)>0){
            if(answer == "n"){
              print("Trace not saved")
              #### Erase the trace is not saved!
              traceIndeces = which(ALLtraces$Date == datei & 
                                     ALLtraces$Stim==stimi &
                                     ALLtraces$id == IDi &
                                     ALLtraces$Leaf == leafi )
              ALLtraces = ALLtraces[-traceIndeces,]
              write.csv(ALLtraces, paste(savename,".csv",sep = ""), row.names = FALSE)
              traceIndeces = c()
              
              break # this should go to the next leaf
              
            } else if( !is.na( as.numeric(answer) )) {
              trace = trimTrace(trace, answer)
            } else {
              print("No valid input ")
              answer <- readline (prompt="Trim trace? Second+ENTER, just ENTER to skip trimming, or >n< for skipping & erasing trace  ")
            }
            
          }  
      
          
  ### FUNCTION TO CALCUATE PARAMETERS         
          SWPanalysis = findSWPvalues(trace$V, 
                                      trace$Seconds[ max(which(trace$DayTime=="F1"))+1] )
          trace = na.omit(trace)
          # Save trace and values independently
          trace$V = SWPanalysis[[1]]
          SWPvalues = SWPanalysis[[2]]
          trace$Seconds = trace$Seconds - SWPvalues$stimFrame  # Make time at stimulus frame = 0
  
          
  
  ### PLOT!        
          plotTitle = paste(IDi,leafi, sep = ".")
          
            plot(x = trace$Seconds, y = trace$V, type = "l", main = plotTitle, ylim=c(-100,40) ) +
            abline(h = SWPvalues$bl.1st, col="black", lty = 2) +
            abline(v = SWPvalues$hyperpol.slope.frame, col="red") +
            abline(v = SWPvalues$depol.slope.frame, col="red") +
            abline(v = SWPvalues$halfmax.repol.frame, col="green") +
            abline(h = SWPvalues$maxDepol, col = "red") +
            abline(h = SWPvalues$maxHyperpol, col = "blue") +
            abline(h = SWPvalues$maxRepol, col = "blue") +
            abline(h = SWPvalues$bl.2nd, col="green", lty = 2) +
            abline(v = 0, col="black", lty = 2)
  
           
            print(paste(datei,IDi,stimi,leafi,sep = "-"))
            print(SWPvalues)
          
          
  #### Save or not
          if(abs(SWPvalues$depol.amplitude) < 10){
            answer <- readline (prompt="NO RESPONSE! save as failed trace? [y];[n]    ")
            if(answer == "y"){
              SWPvalues$depol.duration = NA
              plotTitle = paste("FAIL",plotTitle, sep = "-")
            }
          } else {
            answer <- readline (prompt="Press [y] to save; [n] to skip    ")
          }
            
            
          
          while ( is.null(answer)==FALSE ){ #answer != "y" || answer != "n"
            traceIndeces = which(ALLtraces$Date == datei & 
                                   ALLtraces$Stim==stimi &
                                   ALLtraces$id == IDi &
                                   ALLtraces$Leaf == leafi )
            if (answer == "y") {
              # put in dataframe
              Date = datei
              Stim = stimi
              id = IDi
              Leaf = leafi
              
              # save data
              fTraceSummary = rbind(fTraceSummary, cbind(Date,Stim,id,Leaf,SWPvalues) )
                ## get rid of infinite values
              for(i in 5:ncol(fTraceSummary)){
                fTraceSummary[which(fTraceSummary[,i] == Inf),i] = NaN
              }
              write.csv(fTraceSummary, paste(savename,"Summary.csv",sep = ""), row.names = FALSE)
              
              
        
              # save plot
              pdf(file = paste( savename,"-",datei,"/", plotTitle, ".pdf" , sep = "") )
              plot(x = trace$Seconds, y = trace$V, type = "l", 
                   main = plotTitle, 
                   ylim=c(-100,40),
                   xlab = "s", 
                   ylab = "mV" ) +
                abline(h = SWPvalues$bl.1st, col="black", lty = 2) +
                abline(v = SWPvalues$hyperpol.slope.frame, col="red") +
                abline(v = SWPvalues$depol.slope.frame, col="red") +
                
                abline(v = SWPvalues$halfmax.repol.frame, col="green") +
                abline(h = SWPvalues$maxDepol, col = "red") +
                abline(h = SWPvalues$maxHyperpol, col = "blue") +
                abline(h = SWPvalues$maxRepol, col = "blue") +
                abline(h = SWPvalues$bl.2nd, col="green", lty = 2) +
                abline(v = 0, col="black", lty = 2)
              dev.off()
              
              # update database of traces. label the plotted as plotted.(label the plots?)
              # Set plot status to YES
              ALLtraces$Plot[traceIndeces] = "Yes"
              write.csv(ALLtraces, paste(savename,".csv",sep = ""), row.names = FALSE)
            
              break
            }
            else if (answer == "n") {
              print("Trace not saved")
              #### borrar del archivo si no se guarda!
              ALLtraces = ALLtraces[-traceIndeces,]
              write.csv(ALLtraces, paste(savename,".csv",sep = ""), row.names = FALSE)
              traceIndeces = c()
  
              break
            }
            else {
              print("Not valid input")
              answer <- readline (prompt="Press [y] to save; [n] to skip")
              
            }
          } 
        }
      }
    }
  }
  return(fTraceSummary)
}


home = getwd()
print("Continue with step 2.1 or where you left")
```

///////////////////////////////////////////////////////////////////////////////





# SECTION 2. Load and convert the data from Labscribe into dataframe for analysis.
This chunk will create a folder with the name of your choice. Here all the output will be saved.

2.1. Write your folder's name in the foldername variable. 
     Write your control group in the controlgroup variable. This is the control condition Example. 
     Col0 if the treatment is different genotypes   

                             EDIT THE FOLDER NAME HERE
```{r}

foldername = "output"  # Replace the text in "" with the name you want your folder to have. example: "Col-0-01.01.2000"

# What is your control group?
controlgroup = "Col0" #  
#####
batchFolder = paste(home,foldername,sep="/")
print("Continue with step 2.2") ###
```

2.2. Run this to extract the data and save it in a folder with the name previously given. Ignore the errors that are shown at the end. This is due to the F1 marks in the traces. 

If this stops with an error instead of a success message, the last file printed in the console does not have the proper formatting. Check that column names fit the INPUT conditions above.

If you run this chunk for a second time, make sure to erase the "output" folder created in the previous run. Otherwise your traces will be duplicated in the same file.

output - a folder with the name stated in step 2.1. 
         a ">genotype<.csv" file with all the data for each genotype
         
```{r}
## Load file names
setwd(home)
initialFiles = list.files()
dir.create(batchFolder)

# Loop through all the date-named folder containing the raw data. Saves and prints all the traces found.
files = c()
done = 0
for (f in list.files() ){
  
  ################ Check if it's a folder with content
  if( length(list.files(f)) != 0 ){ 
    files = list.files(f)[  grep(".txt",  list.files(f))  ]
  } 
  else if(length(list.files(f)) == 0) next # skip to next file if doesn't have content
  
  
  
  ################ Loop through all files in folder
  for (i in files){
    print( paste(f,i,sep="_") )
    setwd(paste(home,f,sep = "/")) # go into folder with the files to extract
    traceList = DataExtraction( read.delim(i), f )# load .txt file returns list with all plants recorded in file.
    
    # Save traces to files. Sort by genotype -in another folder-
    for ( p in 1:length(traceList) ){ # loop through plants in list of traces
      setwd(batchFolder) # go to dir specific to that batch
      
      
      
      
    
      # if genotype file of plant "p" exists, open it

      findFile = paste(traceList[[p]]$Genotype[1], ".csv", sep = "")
      if ( length( grep( findFile , list.files( ), fixed = TRUE)) == 1 ){ # looks for EXACT match of genotype.csv i.e., Col0 =! Col0.1
        genotypeData = read.csv( list.files(batchFolder)[ grep(findFile, list.files(batchFolder), fixed = TRUE )] )  
       
        
         # create new, consecutive id number for plants recorded the same date.
        if( length(grep(f, genotypeData$Date)) > 0 ){ # if genotype exists and also date
          traceList[[p]]$id = as.numeric(genotypeData %>% dplyr::filter(Date == f) %>% dplyr::summarise(max(id)) + 1 ) 
        }
        
        
        # if the genotype exists but not the date
        else if(length(grep(f, genotypeData$Date)) == 0){
          traceList[[p]]$id = 1
        } 
        # Uncomment if want to use name of the file (without extension) as id.
        #traceList[[p]]$id = substr(i,1,nchar(i)-4) 
        genotypeData = rbind(genotypeData, traceList[[p]]) # append plant "p" to genotype database
      }
      
      
      
      
      # else, no genotype file yet
      if ( length( grep( paste(traceList[[p]]$Genotype[1], ".csv", sep = ""), list.files( ), fixed = TRUE)) == 0 ){  # looks for EXACT match of genotype. i.e., Col0 =! Col0.1
        traceList[[p]]$id = 1
              # Uncomment if want to use name of the file (without extension) as id.
        #traceList[[p]]$id = substr(i,1,nchar(i)-4) 
        genotypeData = traceList[[p]] # create new file
      }

      
      
      # Down sample to 1Hz if the traces were saved in 10Hz
    newIndeces = sort( 
      c( which(genotypeData$Seconds%%1==0), which(is.na(genotypeData$Seconds)==TRUE) ), 
      decreasing = FALSE)
    genotypeData = genotypeData[newIndeces,]

    
      # save i    
      write.csv(genotypeData, paste( batchFolder,"/",traceList[[p]]$Genotype[1],".csv",sep = "" ), row.names = FALSE )
      print(paste( f, i, traceList[[p]]$Genotype[1], traceList[[p]]$DayTime[1], sep = " - ") )
      done = 1
    } # finish saving all traces "p" in file "i"
  } # finish opening all files in folder "f"
  
  setwd(home)
}
if(done == 1){
 print("Success! continue with step 3.1") 
} else {
  print("No folder with .txt files recognized. Put data in home folder")
}

```

///////////////////////////////////////////////////////////////////////////////





# SECTION 3. Data processing
Input-  ">genotype<.csv" files in the batch folder, in the home directory. As created in step 2.2. 

READ THIS IF YOU WANT TO RUN THIS WHOLE SECTION A SECOND TIME.  Place only the ">genotype<.csv" files in the batch folder and reset them with this chunk.
```{r}
# Reset files to analyze again.
setwd(batchFolder)
files2analyze = list.files(batchFolder)[grep(".csv", list.files(batchFolder))]
pendingFiles = list()
setwd(batchFolder)
for(g in files2analyze) {
  file = read.csv(g)
  file$Plot = "No"
  write.csv(file, g, row.names = FALSE)
}
```


 
3.1. Register traces to be analyzed

- Run to see how many and which traces you have to analyze.

output - Will show you in the console what files are there for analyzing.
```{r}
## Loop through the genotypes recorded in that batch
files2analyze = list.files(batchFolder)[grep(".csv", list.files(batchFolder))]
pendingFiles = list()
setwd(batchFolder)
for(g in files2analyze) {
  pendingFiles[[g]] =c( AmIDone( g ) ) 
}
save(pendingFiles, file="batchTraces.RData")
setwd(home)
print("Continue with step 3.2")
```





3.2. Pick and analyze traces

This function will show you a trace and ask you whether to 
  trim and save,  (input the second at which to trim, then ENTER)
  to only save    (just press enter) or
  to erase        (input n, then ENTER)
  
- Run as many times as required until the step 3.3 says you are done. 
This should run through all traces in the ideal case, but will stop in case some trace is damaged. 
The easiest thing to do is to stop (press esc) when the parameters of a trace are totally off in the plot and trimming the last part does not help. Then re-run this chunk and skip/erase the trace when the program first asks you what to do. 

output - 
  a >genotype< folder with figures of the analyzed traces for both leaves available. 
  Figures names are "#.Lxx.pdf", where:
  - xx is the leaf (08 or 13).
  - # is the plant number, unique in the batch and consistent over all files generated. 
   This allows tracking back to the original plant and trace.
  a ">genotype<Summary.csv" file with the value of all parameters calculated from all leaves of all plants.
```{r}
setwd(batchFolder)

## Function that loops through all the non-analyzed traces of the loaded 
for(f in names(pendingFiles)){
  savename = f
  savename = substr( savename, 1,nchar(savename)-4)
  print( paste("Analyzing ", savename, sep = "") )
## FUNCTION that loads, plots, and calculates parameters. 
  traceSummary = plotAndAnalyze( f )
}
```

3.3.
Check status of analysis

output - Tells you if you are done with all the traces or if you need to keep running the previous step.
```{r}
## Update pending files.
setwd(batchFolder)
for(g in names(pendingFiles) ) {
  pendingFiles[[g]] =c( AmIDone( g ) ) 
}
if(length(pendingFiles) == 0){
  print("You are done! continue to section 4")
  unlink("batchTraces.RData")
  
} else {
  save(pendingFiles, file="batchTraces.RData")
  print("Run again chunk 3.2")
}
setwd(home)
```

///////////////////////////////////////////////////////////////////////////////






# SECTION 4. Plot and run statistics on data parameters.

4.1.
Plot and save one violin plot for each parameter quantified including all genotypes recorded.

output - Violin plots for each parameter, 
          a "yymmdd-basicStats.csv" file with all the values mean, SEM and p-value of Shapiro-Wilk normality test. 
```{r}
setwd(batchFolder)
# Open all the "Summary" files in the folder.
SummaryData = NULL
for( i in grep("Summary", list.files()) ){
  data = read.csv( list.files()[i] )
  data$Genotype = substr(list.files()[i], 1, nchar(list.files()[i])-11 )
  SummaryData = rbind(SummaryData, data )
}


# omit all the recordings clasified as fail. Those have depol.duration = NA
failedtrace = which(is.na(SummaryData$depol.duration))
if (length(failedtrace)>0 ){
  SummaryData = SummaryData[-failedtrace,]
}


# find mean and SEM, shapiro test for each genotype

StatsData = NULL
for ( g in unique(SummaryData$Genotype) ){ # pick genotype
  for(l in unique(dplyr::filter(SummaryData, Genotype==g)$Leaf) ){ # pick leaf for genotype g.
    for( v in which( names(SummaryData)%in%Parameters ) ) { # loop through columns
      data = dplyr::filter(SummaryData, Genotype==g & Leaf==l)[,v] %>% na.omit()
      print(paste(g,l, names(SummaryData)[v] ))
      n = length( data )
      average = mean( data )
      sem = std.error( data )
      # run normality shapiro test
      if(length( data ) < 3 ){
        Shapiro = 0
      } else {
        Shapiro = round( shapiro.test( data )$p.value, 3)
      }

      StatsData = rbind(StatsData, data.frame(g,l,names(SummaryData)[v],average,sem, n, Shapiro ))
    }
  } 
}
names(StatsData) <- c("Genotype","Leaf","Variable", "Mean", "SEM", "N", "ShapiroTest")
write.csv(StatsData, paste(paste(unique(SummaryData$Date),collapse="."),"-basicStats.csv",sep = "" ) )




#############################


# Violin plot for each parameter calculated
My_Theme =  theme(
  axis.text.x = element_text(color = "black", size = 10, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_blank(), 
  axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 10, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_blank(),
  panel.grid.minor.y = element_blank(),
  panel.grid.major.x = element_blank(), 
  panel.grid.minor.x = element_blank()) 

for( v in which( names(SummaryData)%in%Parameters ) ) {
  units = "Voltage (mV)"
  if(names(SummaryData)[v]%in%c("depol.duration", "hyperpol.duration")){
    units = "Time (s)"
  } else if ( names(SummaryData)[v]%in%c("depol.slope","hyperpol.slope") ){
    units = "Slope(mV/s)"
  }
  plotName = paste(paste(unique(SummaryData$Date),collapse="."), "-",
                   names(SummaryData)[v], sep = "")
  traceParamPlot <- ggplot(SummaryData, aes(`Genotype`, SummaryData[,v], color = `Leaf`)) +
  geom_violin() +
  geom_jitter(shape=16, position=position_dodge(1)) +
  scale_fill_discrete(labels = c("A", "D"))+
  ylab (units) + 
  ggtitle(plotName) +
  My_Theme
  print(traceParamPlot)
  ggsave(paste(plotName,".pdf",sep=""),traceParamPlot, width = 6, height = 5, dpi = 300 ) 
  Sys.sleep(0.2)
}

setwd(home)
print(" Continue with step 4.2")
```

4.2.
Plot the mean of all aligned traces chosen in the process above. Saves the plots as PDFs in the batch folder

output - average trace with SEM overlaid for each genotype.
```{r}
setwd(batchFolder)
# Violin plot for each parameter calculated
My_Theme =  theme(
  axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_text(color = "black", size = 25, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #element_blank(), #element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #
  axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), # element_blank(), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_line(), # element_blank()
  panel.grid.minor.y = element_line(),
  panel.grid.major.x = element_line(), #element_line()
  panel.grid.minor.x = element_blank()) 


# loop between genotypes

for(g in  unique(StatsData$Genotype) ){
  genotypeData <-  read.csv(paste(g,".csv",sep = "")) %>% unite("id",id,plant,Date,sep = "_")

  # Organize T-V1-V2...Vn
  for (l in unique(genotypeData$Leaf)){
    Leafdata = genotypeData %>% dplyr::filter(Leaf==l)
    leafn = StatsData %>% filter(Genotype == g, Leaf == l) %>% summarize(mean(N)) %>% as.numeric
    meanPlot =data.frame("Seconds"=c(seq(-30,0),seq(1,270))) 
    for (i in unique(Leafdata$id) ){ 
      mid = strsplit(i,split = "_")[[1]][1] # get back the id for i
      # ver si existe en el SummaryData, si no, skip to next id
      mleaf = l
      mplant = strsplit(i,split = "_")[[1]][2]
      mdate = strsplit(i,split = "_")[[1]][3]
      if(nrow(SummaryData %>% dplyr::filter(Date==mdate,
                                            id==mid,
                                            Leaf==mleaf, 
                                            Genotype==g)) == 0){
        
        next
      }
      vCol = Leafdata %>% dplyr::filter(Leaf==l, id==i) %>% select(V) # pick a single V vector
      # get the frame at which max depol happens for that trace.
     
      stimFrame = SummaryData %>% 
        dplyr::filter(Date==mdate,id==mid,Leaf==mleaf, Genotype==g)%>%
        summarise(stimFrame+halfmax.depol.frame) %>% as.numeric()
      if( is.na(stimFrame) == TRUE ){
        next
      }
        # align to half max
      # Cut the trace 30s before half max and 270s after.
      vCol = data.frame(V = vCol$V[(stimFrame-30):(stimFrame+270)] )
          #plot(x = meanPlot$Seconds,y = vCol$V)
      names(vCol) = i
      meanPlot = cbind(meanPlot,id=vCol)
      
    }
    meanPlot$Mean = rowMeans(meanPlot)
    meanPlot$pSEM = meanPlot$Mean + 
      (apply(meanPlot,1,na.omit(sd))/rowSums(!is.na(meanPlot))  )
    meanPlot$nSEM = meanPlot$Mean -
      (apply(meanPlot,1,na.omit(sd))/rowSums(!is.na(meanPlot))  )
    
    meanOnly = data.frame(Seconds=meanPlot$Seconds, 
                          Mean=meanPlot$Mean,
                          pSEM=meanPlot$pSEM,
                          nSEM=meanPlot$nSEM)
    # Plot mean and SEM
    mplot <- ggplot(na.omit(meanOnly), aes(x = Seconds))+
      geom_line(aes(y = Mean)) +
      geom_line(aes(y = pSEM),alpha=0.5,color="blue") +
      geom_line(aes(y = nSEM),alpha=0.5,color="blue") +
      ylab ("mV") + 
      xlab ("Time (s)") + 
      ylim (-100,40) +
      ggtitle( paste(g,"-",l," n=",round(leafn)," mean±SEM", sep = "") ) +
      My_Theme
    print(mplot)
    ggsave( paste("Mean-",g,"-",l,".pdf",sep = ""), mplot, width = 6, height = 5, dpi = 300  )
  }
}
setwd(home)
print("Congrats! you are done. Start another batch or leave. You deserve it")
```

///////////////////////////////////////////////////////////////////////////////






# SECTION 5. Plot mean after manual data selection

Plot the mean of all aligned traces of ONE genotype, CHOSEN BY HAND. 
input - >genotype<.csv files. INPUT BY HAND THE DATES AND IDs.
output - >genotype<_meanSEM.pdf trace with average trace and SEM overlaid.
">genotype<_MeanPlotData.csv" with the raw data, mean and SEM.
```{r}
# ENTER INFO HERE before running
plot.ids = list( "240819" = c(1),
                 "240826" = c(2,3,4),
                 "240829" = c(1)
      ) # Out of the traces in the >genotype<.#.csv files, which do you want to plot in the average?
genotype = "mslD5" # something else? change here 
leaf = "L13" # "L08"
#####
setwd(home)
data = NULL
for( f in list.files()[grep(".csv",list.files())] ){
  print(f)
  data = rbind(data, read.csv(f))
}

# pick only the traces stated in the list
data.plot = data.frame()
for( i in 1:length(names(plot.ids)) ){
  data.plot = rbind ( data.plot, 
                      dplyr::filter(data, Date %in% names(plot.ids)[i] & 
                      id %in% plot.ids[[i]] &
                      Leaf == leaf) 
                      ) 
}

# determine time only first 300 seconds
time = data.frame("Seconds"= c(0:300) )
# transform and align the data structure 
data.plot = data.plot %>% select(Seconds,V,Date,id) %>% unite(id, 3:4 ,sep="_")
n = unique(data.plot$id) %>% length()
meanPlot = time 
for(i in 1:length(unique(data.plot$id)) ){
  vector.i = dplyr::filter(data.plot, id== unique(data.plot$id)[i])$V
  # plot(vector.i, type="l")
    # align using the max slope
  slope.i = calculateslope(vector.i)
  # plot(slope.i, type="l")
  align.point = which(slope.i == min(na.omit(slope.i)) )
  vector.i = vector.i [(align.point-30):(align.point+270)]
    # put into matrix with the others
  meanPlot =  cbind( meanPlot, data.frame("new" =  vector.i ) ) 
  
  names(meanPlot)[which(names(meanPlot)=="new")] = unique(data.plot$id)[i]
}
head(meanPlot)

# get the mean and SEMs

meanPlot$Mean = rowMeans(meanPlot[2:ncol(meanPlot)])
meanPlot$pSEM = meanPlot$Mean + 
      (apply(meanPlot,1,na.omit(sd))/rowSums(!is.na(meanPlot))  )
meanPlot$nSEM = meanPlot$Mean -
      (apply(meanPlot,1,na.omit(sd))/rowSums(!is.na(meanPlot))  )
# save the selected traces and their mean±SEM
write.csv(meanPlot, paste(genotype,"MeanPlotData.csv",sep = "_") , row.names = FALSE)

# Plot mean and SEM
meanOnly = data.frame(Seconds=meanPlot$Seconds, 
                          Mean=meanPlot$Mean,
                          pSEM=meanPlot$pSEM,
                          nSEM=meanPlot$nSEM)
ggplot(na.omit(meanOnly), aes(x = Seconds))+
  geom_line(aes(y = Mean)) +
  geom_line(aes(y = pSEM),alpha=0.5,color="blue") +
  geom_line(aes(y = nSEM),alpha=0.5,color="blue") +
  ylab ("mV") + 
  xlab ("Time (s)") + 
  ylim (-100,40) +
  ggtitle( paste(genotype,"_",leaf," n=",n," mean±SEM", sep = "") ) +
  theme(
  axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_text(color = "black", size = 25, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), 
  axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_line(),
  panel.grid.minor.y = element_line(),
  panel.grid.major.x = element_line(), 
  panel.grid.minor.x = element_blank() )
ggsave(paste(genotype,"_meanSEM.pdf",sep = ""))
    

```

///////////////////////////////////////////////////////////////////////////////







