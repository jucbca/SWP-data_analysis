---
title: "SWPanalyzer"
output: html_document
date: "2024.07.18"
editor_options: Code developed by Juan Camilo Barbosa-Caro. Team signaling @ Frommer Lab. Düsseldorf-Germany.
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

                                    DESCRIPTION 
        
This script helps you to manipulate and analyze raw data from electrophysiological recordings of plants made with the software LabScribe. It analyzes SWP traces and determines different parameters on which statistics can be run. These parameters are:

Paremeters calculated at:

Hyperpolarization phase
  hyperpol.slope          - Maximum peak of slope in the first hyperpol phase.  
  hyperpol.amplitude      - Hyperpolarization amplitude from first baseline to peak hyperpol 
  hyperpol.duration       - Duration of first hyperpolarization from time @ hyperpol.slope to time @ 
  
Depolarization phase
  depol.slope             - Minimum peak of slope in the depolarization phase.
  depol.amplitude         - Depolarization amplitude from peak hyperpol to peak depol.
  depol.duration          - Time between the following two time points: 
                              I) @ time of depol.slope
                              II) @ time of middle voltage between peak repolarization and peak

Repolarization phase                            
  hyperpol.2nd.amplitude  - Repolarization amplitude from second baseline to peak repolarization.
  bl.2nd                  - Final baseline after SWP is finished

  
  
    
    INPUT:
Data for one experiment (one day of recordings) regardless of the amount of genotypes analyzed. All the traces from plants that grew together and were recorded together are considered to be one experiment.
With this labScribe software and hardware up to 4 electrodes can be used simultaneously. Hence, 2 plants per file. Either 1 or 2 plants can be analyzed here, make sure to follow this labeling rules for that.
    
    
A folder with .txt files with the following structure:
 - Folder named with the date in this structure: "YYMMDD"
 - Raw data should be in .txt files, as exported from LabScribe,

Name the data when recording with labScribe with the following structure
Write all the information about the experiment in the leaf 8 label. Follow this structure for the names of the columns in the .txt file.
        Leaf 8 --         "Ez_Ly.xPG_w" 
        Leaf 13--         "Ez_Ly.x"
        Empty Electrode-- "Ez_Leer"
where:
                 z is the electrode number (1 to 4)
                 y is the leaf on which that electrode is (08 or 13)
                 x is the plant (1 or 2)
                 PG stands for Plyer and Gears as the stimulation device. GL as green light
                 w is the GENOTYPE (text of any length, just avoid "_") it has to be consistent for the system to compile them all together.
                 
Example "E1_L08.1PG_Col0" , "E2_L13.1", "E3_L13.2" , "E4_L08.2PG_mutant"
This is 2 plants. 
- Col-0 with electrodes 1 on leaf 8 and 2 on leaf 13 and
- a mutant with electrodes 3 on leaf 13 and 2 on leaf 08

    OUTPUT:   
1. A folder with a name of choice inputed in step 2.1
In this folder: 
2.  a >genotype<->date< folder with all the traces corresponding to that combination. Each image is saved as the plant#.L##
3.  >genotype<.csv file with the raw data organized as a data frame to use with R or any other coding language.
4.  >genotype<Summary.csv file summarizing for every leaf of every plant all the parameters calculated. Each parameter is a column.
5.  >date<-basicStats.csv file with the Shapiro-Wilk normality test, the Mann-Whitney U test and the Kruskal-Wallis test for each parameter of each leaf of each genotype. Both non-parametric tests are compared to Col0 or any other group stated in step 2.1. This is a guide, ABSOLUTELY re-run these tests, or other more suited to your data, manually with the data provided in point 4.
6.  >date-parameter<.pdf files. One for each parameter - violin plot with all the point separated by genotype and leaf.
7.  Mean->genotype-L##<.pdf files. One for each leaf of each genotype. The graphical mean of all traces ± SEM. 







                                  INSTRUCTIONS

Follow these steps:
  1. Click on create a project on the top left of this window to create a new project. This will create a folder that will be your "home" directory. 

  2. In the "gear" button at the top of the window select "Chunk output in console" instead of "Chunk output inline". This will show all the steps of the process properly in the console.
  
  3. Paste a copy of the exported folders with the .txt data from one batch of experiments into the home folder you just created (use format described above in the INPUT section). 
  
  4. Run the chunks in order (see below how to do that). If ran successfully, each chunk will indicate you to go to the next.
  
  Note: The analysis is divided in 4 sections, each with multiple chunks. Run them in order. 
        There is a checkpoint between sections; this means that it is better if you don't close the program before finishing all the chunks of a section (3.1, 3.2, and 3.3 in 3). If necessary to close the program and continue later, do it after finishing one full section. REMEMBER to run section 1 every time you open the program, even if you are not starting from scratch.

         Analysis sections:
      1. Function and library loading (Run every time you start the program)
      2. Load and convert the data
      3. Pick, trim and analyze summaryzed traces
      4. Plot and run statistics on calculated parameters
      5. Plot a mean ±SEM trace for a genotype or group of traces


                                
Technical guidelines. 
  - For running a chunk click on the green arrow on the right.
  - For learning more about R notebooks check the following link.
https://rmarkdown.rstudio.com/authoring_quick_tour.html

                                   DISCLAIMER OF SCRIPT BIASES 
Traces are filtered with a Savitzky-Golay method which reduces the amplitude (by around 5mV) of traces with a very sharp spike in the peak depolarization. If there is a phenotype at very sharp depolarization, we are probably missing it.








/////////////////////////////////////////START HERE//////////////////////////////////////
   
   
   
                    
# SECTION 1. Function and library loading

- Run this chunk once every time you start the program.
If you don't have the packages installed in your computer do it by typing in the console:
install.packages("name of package")
```{r}
# load packages
library(ggplot2)
library(tidyr)
library(pracma)
library(signal)
library(dplyr)
library(plotrix)
Parameters = c("hyperpol.slope",
               "hyperpol.amplitude",
               "hyperpol.duration",
               
               "depol.slope",
               "depol.amplitude",
               "depol.duration",
               
               "hyperpol.2nd.amplitude", 
               "bl.2nd" )
# Function for parameter finding
DataExtraction <- function(data, date){ 
  output <- list()
  time1 = data$Time
  ToD = data$TimeOfDay
  #determine which have info

  if ( length( grep("L08",names(data)) ) == 1 ){
    PlantNumber = names(data)[grep("L08",names(data)) ] %>% substr(8,8) %>% as.numeric()
  } else if ( length( grep("L08",names(data)) ) > 1 ){
    PlantNumber = c(1,2)
  }
  index = 1
  # Extract info one plant at a time.
    for( n in PlantNumber){

    leaf1 = paste("L08.", n, sep = "")
    leaf2 = paste("L13.",n, sep = "")
    plant1 = data[, grep(leaf1, names(data)): grep(leaf2, names(data))] # pick the columns w/ the data
    # extract info from L08 col (Stim,genotype)
    # from cols 2,3 which have 08
    info1 = names(plant1)[   grep("08", names(plant1))   ]
    # extract from that all necessary info
    stim1 = strsplit(info1,"_")[[1]][2] # separate by "_". save part with the stim. e.g. "L08.1CG"
    stim1 <- substr(stim1,6,nchar(stim1))
    genotype1 = strsplit(info1,"_")[[1]][3] # separate by "_". save part with the stim. e.g. "L08.1CG"
    # rename (Time, L08(V), L13)(V)) and tidy, and convert to numeric corresponding cols.
    plant1 = cbind(time1,plant1)
    names(plant1)[1] <- "Seconds"
    names(plant1)[   grep("08", names(plant1))   ] <- "L08"
    names(plant1)[   grep("13", names(plant1))   ] <- "L13"
    plant1 = gather(plant1, "Leaf", "V", 2:3)
    plant1$plant = n
    plant1$Seconds = as.numeric(plant1$Seconds)
    plant1$`V` = as.numeric(plant1$`V`)*100
    plant1$Genotype = genotype1
    plant1$Stim = stim1
    plant1$Date = date
    plant1$DayTime = ToD
    plant1$Plot = "No"
    
    plant1 = list(plant1)
    output <- append(output,plant1) 
    names(output[index]) <-  paste("plant",n,sep = "")
    index = index+1

  }
  return(output)
}###  LabScribe into data frame. PlantNumber= 1 or 2 per trace (Should make it 4, for each electrode)
AmIDone <- function(file){
  CheckTraces = read.csv(file) 
  pendingList = c()
  if( nrow(  dplyr::filter(CheckTraces, Plot=="No" ))>0  ){
    print( paste("You still need to analyse these plants for ",
                 file, ":", sep = "") )
    pendingTraces = dplyr::filter(CheckTraces, Plot=="No" )
    for(i in unique(pendingTraces$Date) ){
      missingDates = i
      ids = unique( pendingTraces$id[which(pendingTraces$Date==i)] )
      print( paste(i,ids,sep = "-")  )
      pendingList = append(pendingList,paste(i,ids,sep = "-") )
    }
  } else { 
    print( paste("You're done with", file, "!!!") ) 
    }
  return(c(pendingList))
  
}
calculateslope <- function(vector) {
  slopetrace = NULL
  for( i in 2:length(vector)){
    slopei = vector[i]-vector[i-1]
    slopetrace = append(slopetrace, slopei)  
  }
  slopetrace = append(slopetrace, slopetrace[length(slopetrace)])
  return(slopetrace)
}
findSWPvalues <- function(trace, plant){
  ### Set reference time 0 when stimulus is applied: either at the first F1 value or or at the first maximum value.
  if(length( which( is.na(trace)) ) > 0 ){
    stimFrames =   which( is.na(trace))
    if( length( which( is.na(trace))) > 2 ) {
      stimFrames =  which( is.na(trace))[c(1,3)]
    }
    # Pick the first NaN (or F1 in DayTime column) for plant 1, and the 3rd NaN for plant 2
    if( plant == 1){
      stimFrame = stimFrames[1] ### Determines the stimulus frame by finding the first NaN. Which is when the pedal is pressed.
    }
    if( plant == 2){
      stimFrame =   stimFrames[length(stimFrames)]  ### Determines the -later- stimulus frame for plant 2
    }
    
  } else {
    stimFrames =  c(90,95) 
    # Pick the first NaN (or F1 in DayTime column) for plant 1, and the 3rd NaN for plant 2
    if( plant == 1){
      stimFrame = stimFrames[1] ### Determines the stimulus frame by finding the first NaN. Which is when the pedal is pressed.
    }
    if( plant == 2){
      stimFrame =   stimFrames[2]  ### Determines the -later- stimulus frame for plant 2
    }
  }
  
  
  
  
  ### Filter signal
  trace[which(trace < -150)] = trace[1] # Make extreme values equal baseline. It's when the electrode looses contact.
  # smooth with Savitzky-Golay filter. 
  # n is the amount of point befor/after the nth point to be averaged
  # p is the filter order. Dont know what that is.
   trace = sgolayfilt(na.omit(trace) , p = 1, n = 3)
  # trace = na.omit(trace) ## if not filtering, just omit NaNs
  # Check trace (for debugging)
  plot(trace, type = "l")+
    abline(v=stimFrame) 
  


                        ### Initial baseline
  bl.1st = mean(trace[ 1:(stimFrame-2)]) # average from 0 to before stimFrame
  
  
  
  ### Find peak depolarization
  maxDepol = min(   na.omit( trace[ stimFrame:length(trace) ] )   ) # find peak depol. It's extracellular recording, so depol goes to negative
  
  depolFrame = which(trace == maxDepol) # Find frame at maximum depol 
  
  
  
                        ### hyperpol.amplitude
  ### Find peak of first hyperpolarization between stimulus and depol peak
  maxHyperpol = max(  na.omit(trace[ (stimFrame-10) : depolFrame ])   )
  hyperpolFrame =  which(trace == maxHyperpol)# Find frame at maximum hyperpol
  hyperpol.amplitude = maxHyperpol-bl.1st
  
  
  
                        ### depol.amplitude
  depol.amplitude = maxDepol - abs(maxHyperpol) # Calculate max depol from the peak of hyperpol rather than from the initial baseline
  
  
  
  
                        ### minDepolrate frame

  # find the peak slope at depol part of the trace
  # focus on the chunk between max hyperpol an max depol
  depolTrace = trace[hyperpolFrame:depolFrame] #trace[ (stimFrame+10) : depolFrame  ]  
  depoltrace.firstderivative = calculateslope(depolTrace)
  depol.slope =  min(depoltrace.firstderivative)
  halfmax.depol.frame = min( which(depoltrace.firstderivative == depol.slope) )+hyperpolFrame-stimFrame
# to find half max frame, substract the halfMax V from the trace and pick the closest to 0.
  # halfmax.depol.frame = min (
  #   which (  abs((depolTrace)-halfDepol ) == min( abs((depolTrace)-halfDepol))  )  ## Find the time at Halfdepol
  # ) #+ stimFrame 
  
  
  
                      ### max hyperpol rate
  # focus on the chunk between max hyperpol an max depol
  hyperpolTrace = trace[(hyperpolFrame-20) : hyperpolFrame] # checks the trace 20s before the peak hyperpol.
  hyperpoltrace.firstderivative = calculateslope(hyperpolTrace)
  hyperpol.slope = max(hyperpoltrace.firstderivative)
  ### Save time of max slope
  depol.slope.frame = min( which(hyperpoltrace.firstderivative == hyperpol.slope) )+hyperpolFrame-20-stimFrame
  
                      ### hyperpol.duration from max hyperpol slope to min depol slope
  
  hyperpol.duration = halfmax.depol.frame - depol.slope.frame
  
                          ### second baseline
  ### Find second baseline i.e. after repolarization
  bl.2nd = mean(trace[   (length(trace)-60): length(trace)   ])
  
  
  
  
                        ### hyperpol.2nd.amplitude
    # focus on repolarization part of the trace
  repolTrace = trace[(depolFrame+1):length(trace)]
  maxRepol = max(repolTrace) # maximum repolarization
  maxRepolframe = which(repolTrace == maxRepol)+depolFrame
  hyperpol.2nd.amplitude = maxRepol-bl.2nd # Find hyperpolarization amplitude in the recovery phase
  # former maxHyperpol2
  
  
                        ### maxRepol/2 frame
  halfRepol = maxRepol + ((maxDepol-maxRepol)/2) # bl.2nd + (maxDepol - bl.2nd)/2 # 
  halfmax.repol.frame =  max( which( abs(repolTrace-halfRepol) <= min(abs(repolTrace-halfRepol))+1 ) )   + depolFrame - stimFrame
    
  
                            ### Depolarization duration
  #Time from halfmax raise and decay        
  depol.duration = halfmax.repol.frame - halfmax.depol.frame
  
  
  #return all these
  SWPvalues = data.frame(
  bl.1st,
  maxDepol,
  hyperpol.amplitude,
  hyperpol.slope,
  depol.slope.frame,
  maxHyperpol,
  halfmax.depol.frame,
  depol.slope,
  depol.amplitude,
  halfmax.repol.frame,
  maxRepol, 
  hyperpol.2nd.amplitude,
  bl.2nd,
  depol.duration,
  hyperpol.duration,
  stimFrame
  )
  return( list(trace, SWPvalues))
  
}
trimTrace <-function(trace, second){
  trimFrame = which(trace$Seconds == second)
  trace = trace[1:trimFrame,]
  plot(trace$V, type="l")
  return(trace)
}
plotAndAnalyze <- function(genotypeFile){
  # Load file newly
  ALLtraces = read.csv( genotypeFile )
  # Load summary file if exists.
  if( file.exists( paste(savename,"Summary.csv",sep = "")) )  {
    fTraceSummary = read.csv( paste(savename,"Summary.csv",sep = "") )
  } else {
    fTraceSummary = NULL
  }
  # start w/ emptying variables
  Date = c()
  Stim = c()
  id = c()
  Leaf = c()
#### filter to get to one single plant
  subSet0 = dplyr::filter(ALLtraces,Plot == "No") 
  for (datei in unique(subSet0$Date)){ # pick one date
    subSet1 = dplyr::filter(subSet0, Date == datei)
    # create folder if it doesn't exist
    if( dir.exists(paste( savename,"-",datei,sep = ""))==FALSE ){
      dir.create(paste( savename,"-",datei,sep = ""))
    }
     for(stimi in unique(subSet1$Stim) ) { # pick one stimulus form
      subSet2 = dplyr::filter(subSet1, Stim == stimi) 
      for(IDi in unique(subSet2$id) ) { # pick one id
        subSet3 = dplyr::filter(subSet2, id == IDi) 
        for (leafi in unique(subSet3$Leaf) ){ # pick a leaf
          # single trace to be analyzed
          trace = dplyr::filter(subSet3, Leaf == leafi)
          
          ### Check trace to decide if needs trimming of final part
          
          
          plot(trace$V, type="l")
          
          
          
          # Trim or not
          answer <- readline (prompt="Trim trace? Second+ENTER, just ENTER to skip trimming, or >n< for skipping & erasing trace  ")
          if(nchar(answer)>0){
            if(answer == "n"){
              print("Trace not saved")
              #### Erase the trace is not saved!
              traceIndeces = which(ALLtraces$Date == datei & 
                                     ALLtraces$Stim==stimi &
                                     ALLtraces$id == IDi &
                                     ALLtraces$Leaf == leafi )
              ALLtraces = ALLtraces[-traceIndeces,]
              write.csv(ALLtraces, paste(savename,".csv",sep = ""), row.names = FALSE)
              traceIndeces = c()
              
              break # this should go to the next leaf
              
            } else if( !is.na( as.numeric(answer) )) {
              trace = trimTrace(trace, answer)
            } else {
              print("No valid input ")
              answer <- readline (prompt="Trim trace? Second+ENTER, just ENTER to skip trimming, or >n< for skipping & erasing trace  ")
            }
            
          }  
      
          
  ### FUNCTION TO CALCUATE PARAMETERS         
          SWPanalysis = findSWPvalues(trace$V, trace$plant[1])
          trace = na.omit(trace)
          # Save trace and values independently
          trace$V = SWPanalysis[[1]]
          SWPvalues = SWPanalysis[[2]]
          trace$Seconds = trace$Seconds - SWPvalues$stimFrame  # Make time at stimulus frame = 0
  
          
  
  ### PLOT!        
          plotTitle = paste(IDi,leafi, sep = ".")
          
            plot(x = trace$Seconds, y = trace$V, type = "l", main = plotTitle, ylim=c(-100,40) ) +
            abline(h = SWPvalues$bl.1st, col="black", lty = 2) +
            abline(v = SWPvalues$halfmax.depol.frame, col="red") +
            abline(v = SWPvalues$depol.slope.frame, col="red") +
            abline(v = SWPvalues$halfmax.repol.frame, col="green") +
            abline(h = SWPvalues$maxDepol, col = "red") +
            abline(h = SWPvalues$maxHyperpol, col = "blue") +
            abline(h = SWPvalues$maxRepol, col = "blue") +
            abline(h = SWPvalues$bl.2nd, col="green", lty = 2) +
            abline(v = 0, col="black", lty = 2)
  
           
            print(paste(datei,IDi,stimi,leafi,sep = "-"))
            print(SWPvalues)
          
          
  #### Save or not
          if(abs(SWPvalues$depol.amplitude) < 10){
            answer <- readline (prompt="NO RESPONSE! save as failed trace? [y];[n]    ")
            if(answer == "y"){
              SWPvalues$depol.duration = NA
              plotTitle = paste("FAIL",plotTitle, sep = "-")
            }
          } else {
            answer <- readline (prompt="Press [y] to save; [n] to skip    ")
          }
            
            
          
          while ( is.null(answer)==FALSE ){ #answer != "y" || answer != "n"
            traceIndeces = which(ALLtraces$Date == datei & 
                                   ALLtraces$Stim==stimi &
                                   ALLtraces$id == IDi &
                                   ALLtraces$Leaf == leafi )
            if (answer == "y") {
              # put in dataframe
              Date = datei
              Stim = stimi
              id = IDi
              Leaf = leafi
              
              # save data
              fTraceSummary = rbind(fTraceSummary, cbind(Date,Stim,id,Leaf,SWPvalues) )
                ## get rid of infinite values
              for(i in 5:ncol(fTraceSummary)){
                fTraceSummary[which(fTraceSummary[,i] == Inf),i] = NaN
              }
              write.csv(fTraceSummary, paste(savename,"Summary.csv",sep = ""), row.names = FALSE)
              
              # save plot
              pdf(file = paste( savename,"-",datei,"/", plotTitle, ".pdf" , sep = "") )
              plot(x = trace$Seconds, y = trace$V, type = "l", main = plotTitle, ylim=c(-100,40)) +
                abline(h = SWPvalues$bl.1st, col="black", lty = 2) +
                abline(v = SWPvalues$halfmax.depol.frame, col="red") +
                abline(v = SWPvalues$depol.slope.frame, col="red") +
                
                abline(v = SWPvalues$halfmax.repol.frame, col="green") +
                abline(h = SWPvalues$maxDepol, col = "red") +
                abline(h = SWPvalues$maxHyperpol, col = "blue") +
                abline(h = SWPvalues$maxRepol, col = "blue") +
                abline(h = SWPvalues$bl.2nd, col="green", lty = 2) +
                abline(v = 0, col="black", lty = 2) 
              dev.off()
              
              # update database of traces. label the plotted as plotted.
              # Set plot status to YES
              ALLtraces$Plot[traceIndeces] = "Yes"
              write.csv(ALLtraces, paste(savename,".csv",sep = ""), row.names = FALSE)
            
              break
            }
            else if (answer == "n") {
              print("Trace not saved")
              #### borrar del archivo si no se guarda!
              ALLtraces = ALLtraces[-traceIndeces,]
              write.csv(ALLtraces, paste(savename,".csv",sep = ""), row.names = FALSE)
              traceIndeces = c()
  
              break
            }
            else {
              print("Not valid input")
              answer <- readline (prompt="Press [y] to save; [n] to skip")
              
            }
          } 
        }
      }
    }
  }
  return(fTraceSummary)
}


home = getwd()
print("Continue with step 2.1 or where you left")
```

///////////////////////////////////////////////////////////////////////////////





# SECTION 2. Load and convert the data from Labscribe into dataframe for analysis.
Create a folder with the name of your election. Here all the output will be saved.

2.1. Write your folder's name in the foldername variable. 
     Wrire your control group in the controlgroup variable. This is the control condition Example. Col0 if the treatment is different genotypes   
                   Mannitol if the treatment is different drugs 

                             EDIT THE FOLDER NAME HERE
```{r}

foldername = "tst"  # Replace the text in "" with the name you want your folder to have. example: "Col-0-01.01.2000"

# What is your control group?
controlgroup = "Col0" #  "Col0.Mannitol1mM" #  
#####
batchFolder = paste(home,foldername,sep="/")
print("Continue with step 2.2") ###
```

2.2. Run this to extract the data and save it in a folder with the name previously given. Ignore the errors that are shown at the end. This is due to the pedal (F1) marks in the traces. Check that you have the >genotype<.csv files in the folder that you created in the last step and continue with step 3.

If this stops with an error instead of a success message, the file last printed does not have the proper formating. Check that column names fit the INPUT conditions above.

If you run this chunk for a second time, make sure to erase the files created in the previous run. Otherwise your traces will be duplicated in the same file.
```{r}
## Load file names
setwd(home)
initialFiles = list.files()
dir.create(batchFolder)

# Loop through all the date-named folder containing the raw data. Saves and prints all the traces found.
files = c()
done = 0
for (f in list.files() ){
  
  ################ Check if it's a folder with content
  if( length(list.files(f)) != 0 ){ 
    files = list.files(f)[  grep(".txt",  list.files(f))  ]
  } 
  else if(length(list.files(f)) == 0) next # skip to next file if doesn't have content
  
  
  
  ################ Loop through all files in folder
  for (i in files){
    print( paste(f,i,sep="_") )
    setwd(paste(home,f,sep = "/")) # go into folder with the files to extract
    traceList = DataExtraction( read.delim(i), f )# load .txt file returns list with all plants recorded in file.

    
    # Save traces to files. Sort by genotype -in another folder-
    for ( p in 1:length(traceList) ){ # loop through plants in list of traces
      setwd(batchFolder) # go to dir specific to that batch
      
      
    
      # if genotype file of plant "p" exists, open it
      
      
      
      findFile = paste(traceList[[p]]$Genotype[1], ".csv", sep = "")
      if ( length( grep( findFile , list.files( ), fixed = TRUE)) == 1 ){ # looks for EXACT match of genotype.csv i.e., Col0 =! Col0.1
        genotypeData = read.csv( list.files(batchFolder)[ grep(findFile, list.files(batchFolder), fixed = TRUE )] )  
       
        
         # create new, consecutive id number for plants recorded the same date.
        if( length(grep(f, genotypeData$Date)) > 0 ){ # if genotype exists and also date
          traceList[[p]]$id = as.numeric(genotypeData %>% dplyr::filter(Date == f) %>% dplyr::summarise(max(id)) + 1 ) 
        }
        
        
        # if the genotype exists but not the date
        else if(length(grep(f, genotypeData$Date)) == 0){
          traceList[[p]]$id = 1
        } 
       
        genotypeData = rbind(genotypeData, traceList[[p]]) # append plant "p" to genotype database
      }
      
      
      
      
      # else, no genotype file yet
      if ( length( grep( paste(traceList[[p]]$Genotype[1], ".csv", sep = ""), list.files( ), fixed = TRUE)) == 0 ){  # looks for EXACT match of genotype. i.e., Col0 =! Col0.1
        traceList[[p]]$id = 1
        genotypeData = traceList[[p]] # create new file
      }
      
      
      # Down sample to 1Hz if the traces were saved in 10Hz
    newIndeces = sort( 
      c( which(genotypeData$Seconds%%1==0), which(is.na(genotypeData$Seconds)==TRUE) ), 
      decreasing = FALSE)
    genotypeData = genotypeData[newIndeces,]

    
      # save i    
      write.csv(genotypeData, paste( batchFolder,"/",traceList[[p]]$Genotype[1],".csv",sep = "" ), row.names = FALSE )
      print(paste( f, i, traceList[[p]]$Genotype[1], traceList[[p]]$DayTime[1], sep = " - ") )
      done = 1
    } # finish saving all traces "p" in file "i"
  } # finish opening all files in folder "f"
  
  setwd(home)
}
if(done == 1){
 print("Success! continue with step 3.1") 
} else {
  print("No folder with .txt files recognized. Put data in home folder")
}

```

///////////////////////////////////////////////////////////////////////////////





# SECTION 3. Data processing
Make sure you have the batch folder in the home directory, as created in step 2.2. 
Also make sure to have written and run step 2.1 with the proper batch folder name.

 
3.1. Check traces to be done

- Run to see how many and which traces you have to analyze.
```{r}
## Loop through the genotypes recorded in that batch
files2analyze = list.files(batchFolder)[grep(".csv", list.files(batchFolder))]
pendingFiles = list()
setwd(batchFolder)
for(g in files2analyze) {
  pendingFiles[[g]] =c( AmIDone( g ) ) 
}
save(pendingFiles, file="batchTraces.RData")
setwd(home)
print("Continue with step 3.2")
```


3.2. Pick and analyze traces

This function will show you a trace and ask you whether to 
  trim and save,  (input the second at which to trim, then ENTER)
  to only save    (just press enter) or
  to erase        (input n, then ENTER)
  
- Run as many times as required until the step 3.3 tells you are done. This should run through all traces in the ideal case, but will stop in case some trace is damaged. The easiest thing to do is to re-run this chunk and skip/erase the trace when the program first asks you what to do. 
```{r}
setwd(batchFolder)

## Function that loops through all the non-analyzed traces of the loaded 
for(f in names(pendingFiles)){
  savename = f
  savename = substr( savename, 1,nchar(savename)-4)
  print( paste("Analyzing ", savename, sep = "") )
## FUNCTION that loads, plots, and calculates parameters. 
  traceSummary = plotAndAnalyze( f )
}
```

3.3.
Check status of analysis
```{r}
## Update pending files.
setwd(batchFolder)
for(g in names(pendingFiles) ) {
  pendingFiles[[g]] =c( AmIDone( g ) ) 
}
if(length(pendingFiles) == 0){
  print("You are done! continue to step 4")
  unlink("batchTraces.RData")
  
} else {
  save(pendingFiles, file="batchTraces.RData")
  print("Run again chunk 3.2")
}
setwd(home)
```

///////////////////////////////////////////////////////////////////////////////






# SECTION 4. Plot and run statistics on data parameters.

4.1.
Plot and save one violin plot for each parameter quantified including all genotypes recorded.
```{r}
setwd(batchFolder)
# Open all the "Summary" files in the folder.
SummaryData = NULL
for( i in grep("Summary", list.files()) ){
  data = read.csv( list.files()[i] )
  data$Genotype = substr(list.files()[i], 1, nchar(list.files()[i])-11 )
  SummaryData = rbind(SummaryData, data )
}


# omit all the recordings clasified as fail. Those have depol.duration = NA
failedtrace = which(is.na(SummaryData$depol.duration))
if (length(failedtrace)>0 ){
  SummaryData = SummaryData[-failedtrace,]
}


# find mean and SEM, shapiro test for each genotype

StatsData = NULL
for ( g in unique(SummaryData$Genotype) ){ # pick genotype
  for(l in unique(dplyr::filter(SummaryData, Genotype==g)$Leaf) ){ # pick leaf for genotype g.
    for( v in which( names(SummaryData)%in%Parameters ) ) { # loop through columns
      data = dplyr::filter(SummaryData, Genotype==g & Leaf==l)[,v] %>% na.omit()
      print(paste(g,l, names(SummaryData)[v] ))
      n = length( data )
      average = mean( data )
      sem = std.error( data )
      # run normality shapiro test
      if(length( data ) < 3 ){
        Shapiro = 0
      } else {
        Shapiro = round( shapiro.test( data )$p.value, 3)
      }

      StatsData = rbind(StatsData, data.frame(g,l,names(SummaryData)[v],average,sem, n, Shapiro ))
    }
  } 
}
names(StatsData) <- c("Genotype","Leaf","Variable", "Mean", "SEM", "N", "ShapiroTest")
write.csv(StatsData, paste(paste(unique(SummaryData$Date),collapse="."),"-basicStats.csv",sep = "" ) )




#############################


# Violin plot for each parameter calculated
My_Theme =  theme(
  axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_blank(), 
  axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_blank(),
  panel.grid.minor.y = element_blank(),
  panel.grid.major.x = element_blank(), 
  panel.grid.minor.x = element_blank()) 

for( v in which( names(SummaryData)%in%Parameters ) ) {
  units = "Voltage (mV)"
  if(names(SummaryData)[v]=="depol.duration"){
    units = "Time (s)"
  } else if ( names(SummaryData)[v]%in%c("depol.slope","hyperpol.slope") ){
    units = "Slope(mV/s)"
  }
  plotName = paste(paste(unique(SummaryData$Date),collapse="."), "-",
                   names(SummaryData)[v], sep = "")
  traceParamPlot <- ggplot(SummaryData, aes(`Genotype`, SummaryData[,v], color = `Leaf`)) +
  geom_violin() +
  geom_jitter(shape=16, position=position_dodge(1)) +
    
  geom_label(data = dplyr::filter(StatsData, Variable == names(SummaryData)[v]) ,
             aes(label = `ShapiroTest`, y = Inf), inherit.aes = TRUE, 
             position=position_dodge(1), vjust = 1.5 ) +

  ylab (units) + 
  ggtitle(plotName) +
  My_Theme
  print(traceParamPlot)
  ggsave(paste(plotName,".pdf",sep=""),traceParamPlot )
  Sys.sleep(0.2)
}

setwd(home)
print(" Continue with step 4.2")
```

4.2.
Plot the mean of all aligned traces chosen in the process above. Saves the plots as PDFs in the batch folder
input - StatsData from step 4.1, >genotype<.csv files for genotypes in StatsData, SummaryData compiled from summary files in step 4.1
output - average trace with SEM overlaid.
```{r}
setwd(batchFolder)
# Violin plot for each parameter calculated
My_Theme =  theme(
  axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_text(color = "black", size = 25, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #element_blank(), #element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #
  axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), # element_blank(), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_line(), # element_blank()
  panel.grid.minor.y = element_line(),
  panel.grid.major.x = element_line(), #element_line()
  panel.grid.minor.x = element_blank()) 


# loop between genotypes

for(g in  unique(StatsData$Genotype)){
  genotypeData <-  read.csv(paste(g,".csv",sep = "")) %>% unite("id",id,plant,Date,sep = "_")

  # Organize T-V1-V2...Vn
  for (l in unique(genotypeData$Leaf)){
    Leafdata = genotypeData %>% dplyr::filter(Leaf==l)
    leafn = StatsData %>% filter(Genotype == g, Leaf == l) %>% summarize(mean(N)) %>% as.numeric
    meanPlot =data.frame("Seconds"=c(seq(-30,0),seq(1,270))) 
    for (i in unique(Leafdata$id) ){ 
      mid = strsplit(i,split = "_")[[1]][1] # get back the id for i
      # ver si existe en el SummaryData, si no, skip to next id
      mleaf = l
      mplant = strsplit(i,split = "_")[[1]][2]
      mdate = strsplit(i,split = "_")[[1]][3]
      if(nrow(SummaryData %>% dplyr::filter(Date==mdate,
                                            id==mid,
                                            Leaf==mleaf, 
                                            Genotype==g)) == 0){
        
        next
      }
      vCol = Leafdata %>% dplyr::filter(Leaf==l, id==i) %>% select(V) # pick a single V vector
      # get the frame at which max depol happens for that trace.
     
      stimFrame = SummaryData %>% 
        dplyr::filter(Date==mdate,id==mid,Leaf==mleaf, Genotype==g)%>%
        summarise(stimFrame+halfmax.depol.frame) %>% as.numeric()
          #print(stimFrame)
        # align to half max
      # Cut the trace 30s before half max and 270s after.
      vCol = data.frame(V = vCol$V[(stimFrame-30):(stimFrame+270)] )
          #plot(x = meanPlot$Seconds,y = vCol$V)
      names(vCol) = i
      meanPlot = cbind(meanPlot,id=vCol)
      
    }
    meanPlot$Mean = rowMeans(meanPlot)
    meanPlot$pSEM = meanPlot$Mean + 
      (apply(meanPlot,1,na.omit(sd))/rowSums(!is.na(meanPlot))  )
    meanPlot$nSEM = meanPlot$Mean -
      (apply(meanPlot,1,na.omit(sd))/rowSums(!is.na(meanPlot))  )
    
    meanOnly = data.frame(Seconds=meanPlot$Seconds, 
                          Mean=meanPlot$Mean,
                          pSEM=meanPlot$pSEM,
                          nSEM=meanPlot$nSEM)
    # Plot mean and SEM
    mplot <- ggplot(na.omit(meanOnly), aes(x = Seconds))+
      geom_line(aes(y = Mean)) +
      geom_line(aes(y = pSEM),alpha=0.5,color="blue") +
      geom_line(aes(y = nSEM),alpha=0.5,color="blue") +
      ylab ("mV") + 
      xlab ("Time (s)") + 
      ylim (-100,40) +
        #labs(color = "Leaf") +
      ggtitle( paste(g,"-",l," n=",round(leafn)," mean±SEM", sep = "") ) +
      My_Theme
    Sys.sleep(2)
    print(mplot)
    ggsave( paste("Mean-",g,"-",l,".pdf",sep = ""), mplot )
  }
}
setwd(home)
print("Congrats! you are done. Start another batch or leave. You deserve it")
```

///////////////////////////////////////////////////////////////////////////////






# SECTION 5. Plot mean after manual data selection

Plot the mean of all aligned traces of ONE genotype, CHOSEN BY HAND. 
input - >genotype<.#.csv files. INPUT BY HAND THE DATES AND IDs.
output - >genotype<_meanSEM.pdf trace with average trace and SEM overlaid.
">genotype<_MeanPlotData.csv" with the raw data, mean and SEM.
```{r}
# ENTER INFO HERE before running
plot.ids = list( "230228" = c(1,3,4,5,7,8,9,10,11,14,15,16,17,18,19,20),
                 "231005" = c(2,3,6,7,8,9,10,13,14,15,16,18), #,12
                 "231121" = c(2,3,4,5,6,7,10,11,14)
      )
genotype = "Col-0"

#####
setwd(home)
data = NULL
for( f in list.files()[grep(".csv",list.files())] ){
  print(f)
  data = rbind(data, read.csv(f))
}

# data = read.csv("MeanPlotData.csv")
# pick only the traces stated in the list
data.plot = data.frame()
for( i in 1:length(names(plot.ids)) ){
  data.plot = rbind ( data.plot, 
                      dplyr::filter(data, Date %in% names(plot.ids)[i] & 
                      id %in% plot.ids[[i]] &
                      Leaf == "L13") 
                      ) 
}

# determine time only first 300 seconds
time = data.frame("Seconds"= c(0:599) )
# transform and align the data structure 
data.plot = data.plot %>% select(Seconds,V,Date,id) %>% unite(id, 3:4 ,sep="_")
n = unique(data.plot$id) %>% length()
meanPlot = time 
for(i in 1:length(unique(data.plot$id)) ){
  vector.i = dplyr::filter(data.plot, id== unique(data.plot$id)[i])$V
  # plot(vector.i, type="l")
    # align using the max slope
  slope.i = calculateslope(vector.i)
  # plot(slope.i, type="l")
  align.point = which(slope.i == min(na.omit(slope.i)) )
  vector.i = vector.i [(align.point-99):(align.point+500)]
    # put into matrix with the others
  meanPlot =  cbind( meanPlot, data.frame("new" =  vector.i ) ) 
  
  names(meanPlot)[which(names(meanPlot)=="new")] = unique(data.plot$id)[i]
}
head(meanPlot)

# get the mean and SEMs

meanPlot$Mean = rowMeans(meanPlot[2:ncol(meanPlot)])
meanPlot$pSEM = meanPlot$Mean + 
      (apply(meanPlot,1,na.omit(sd))/rowSums(!is.na(meanPlot))  )
meanPlot$nSEM = meanPlot$Mean -
      (apply(meanPlot,1,na.omit(sd))/rowSums(!is.na(meanPlot))  )
# save the selected traces and their mean±SEM
write.csv(meanPlot, paste(genotype,"MeanPlotData.csv",sep = "_") , row.names = FALSE)

# Plot mean and SEM
meanOnly = data.frame(Seconds=meanPlot$Seconds, 
                          Mean=meanPlot$Mean,
                          pSEM=meanPlot$pSEM,
                          nSEM=meanPlot$nSEM)
ggplot(na.omit(meanOnly), aes(x = Seconds))+
  geom_line(aes(y = Mean)) +
  geom_line(aes(y = pSEM),alpha=0.5,color="blue") +
  geom_line(aes(y = nSEM),alpha=0.5,color="blue") +
  ylab ("mV") + 
  xlab ("Time (s)") + 
  ylim (-100,40) +
    #labs(color = "Leaf") +
  ggtitle( paste(genotype,"_L13"," n=",n," mean±SEM", sep = "") ) +
  theme(
  axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_text(color = "black", size = 25, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #element_blank(), #element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #
  axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), # element_blank(), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_line(), # element_blank()
  panel.grid.minor.y = element_line(),
  panel.grid.major.x = element_line(), #element_line()
  panel.grid.minor.x = element_blank() )
ggsave(paste(genotype,"_meanSEM.pdf",sep = ""))
    

```

///////////////////////////////////////////////////////////////////////////////







